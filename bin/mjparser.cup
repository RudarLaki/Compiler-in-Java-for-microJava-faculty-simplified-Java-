package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());

	public void report_fatal_error(String message, Object info) throws java.lang.Exception{
		done_parsing();
		report_error(message, info);
	}
	
	public void syntax_error(Symbol cur_token){
		report_error("\nSintaksna greska", cur_token);
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception{
		report_fatal_error("Fatalna greska, parsiranje nemoguce nastaviti", cur_token);
	}
	
	public void report_error(String message, Object info){
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
			msg.append(" na liniji ").append(((Symbol)info).left);
		log.error(msg.toString());
	}
:}

init with {:
	errorDetected = false;
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if(s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM,

		 CONST,
		 ENUM,

		 NEW,
		 PRINT,
		 READ,
		 RETURN,
		 VOID,
		 BREAK,
		 CONTINUE,
		 FOR,
		 LENGTH,
		 
		 IF,
		 ELSE,
		 SWITCH,
		 CASE,
		 
		 PLUS,
		 MINUS,
		 MUL,
		 DIV,
		 MOD,
		 ASSIGN,
		 INC,
		 DEC,
		 
		 EQ,
		 NEQ,
		 GREATER,
		 GREATER_EQUAL,
		 LESS,
		 LESS_EQUAL,
		 AND,
		 OR,
		 
		 SEMICOLON,
		 COLON,
		 COMMA,
		 DOT,
		 
		 LPAREN,
		 RPAREN,
		 LBRACKET,
		 RBRACKET,
		 LBRACE,
		 RBRACE,
		 QUESTION_MARK;


terminal String IDENT;
terminal Integer BOOL, NUMBER;
terminal Character CHAR;

nonterminal Program,
			ProgramName,
			
			DeclList,
			MethodDeclList,
			ConstDeclList,
			VarDeclList,
			EnumDecl,
			
			VarDiffDecl,
			VarDecl,
			VarDeclListRest,
			Type,
			
			EnumItemsList,
			EnumItemsRest,
			EnumItem,
			EnumName,
			
			ConstDecl,
			ConstDeclListRest,
			Constant,
			
			Prefix,
			MethodDecl,
			MethodName,
			ParamsList,
			ParamsListRest,
			Param,
			
			Statement,
			MatchedStatement,
			UnmatchedStatement,
			DesignatorStatement,
			SwitchWord,
			SwitchCases,
			ForExpression,
			ForWord,
			StatementList,
			EpsilonDesignatorStatement,
			
			DotDesignatorOp,
			ActPars,
			ActParsList,
			ActParsRest,

		
			UnaryMinus,
			
			Addop,
			Mulop,
			Assignop,
			Relop;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Expression, 
												   NonTernaryExpression,
												   TernaryExpression, 
												   TermList, 
												   Term, 
												   FactorList, 
												   Factor, 
												   PartFactor,
												   
												   Condition,
												   ConditionRest,
												   CondTerm,
												   CondFactRest,
												   CondFact,
												   
												   ReturnExpression,
												   PrintExpression;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator,
												DesignatorArrayName;	
			

Program ::= (Program) PROGRAM ProgramName DeclList LBRACE MethodDeclList RBRACE;

ProgramName ::= (ProgramName) IDENT;

DeclList ::= (DeclList_const) ConstDeclList DeclList
			 |
			 (DeclList_var) VarDeclList DeclList
			 |
			 (DeclList_enum) EnumDecl DeclList
			 |					 
			 (DeclList_e) /*epsilon*/
			 ;

VarDiffDecl ::= (VarDiffDecl_list) VarDeclList VarDiffDecl
				|
				(VarDiffDecl_e) /* epsilon */
				; 

VarDeclList ::= (VarDeclList_array) Type VarDecl VarDeclListRest SEMICOLON;

VarDeclListRest ::= (VarDeclListRest_comma) COMMA VarDecl VarDeclListRest
					|
					(VarDeclListRest_e) /* epsilon */
					;

VarDecl ::= (IdentVarDecl) IDENT
			|
			(ArrayVarDecl) IDENT LBRACKET RBRACKET
			;


ConstDeclList ::= (ConstDeclList) CONST Type ConstDecl ConstDeclListRest SEMICOLON;

ConstDeclListRest ::= (ConstDeclListRest_comma) COMMA  ConstDecl ConstDeclListRest
					  |
					  (ConstDeclListRest_e) /* epsilon */
					  ;

ConstDecl ::= (ConstDecl) IDENT ASSIGN Constant;

Constant ::= (Constant_num) NUMBER
			 |
			 (Constant_char) CHAR
			 |
			 (Constant_bool) BOOL
			 ;


EnumDecl ::= (EnumDecl) ENUM EnumName LBRACE EnumItemsList RBRACE;

EnumItemsList ::= (EnumItemsList) EnumItem EnumItemsRest;

EnumItemsRest ::= (EnumItemsRest_comma) COMMA EnumItem EnumItemsRest
				  |
				  (EnumItemsRest_e) /* epsilon */
				  ;

EnumItem ::= (IdentEnumItem) IDENT 
			 |
			 (AssignEnumItem) IDENT ASSIGN NUMBER
			 ;
			 
EnumName ::= (EnumName) IDENT;


MethodDeclList ::= (MethodDeclList_array) MethodDecl MethodDeclList
				   |
				   (MethodDeclList_e) /* epsilon */
				   ;

MethodDecl ::= (MethodDecl) Prefix MethodName LPAREN ParamsList RPAREN VarDiffDecl LBRACE StatementList RBRACE;

Prefix ::= (TypePrefix) Type
		   |
		   (VoidPrefix) VOID
		   ;

MethodName ::= (MethodName) IDENT;

ParamsList ::= (ParamsList_param) Type VarDecl ParamsListRest
			   |
			   (ParamsList_e)/* epsilon */ 
			   ;

ParamsListRest ::= (ParamsListRest_param) COMMA Type VarDecl ParamsListRest
				   |
				   (ParamsListRest_e) /* epsilon */
				   ;

Type ::= (Type) IDENT;

Statement ::= (MatchStatement) MatchedStatement
			  |
			  (UnmatchStatement) UnmatchedStatement
			  ;

MatchedStatement ::=  (DesigStatement) DesignatorStatement SEMICOLON
					  |
					  (IfElseStatement) IF LPAREN Condition RPAREN MatchedStatement ELSE MatchedStatement
					  |
					  (BreakStatement) BREAK SEMICOLON
					  |
					  (ContinueStatement) CONTINUE SEMICOLON
					  |
					  (ReturnStatement) RETURN ReturnExpression SEMICOLON
					  |
					  (ReadStatement) READ LPAREN Designator RPAREN SEMICOLON
					  |
					  (PrintStatement) PRINT LPAREN PrintExpression RPAREN SEMICOLON
					  |
					  (SwitchStatement) SwitchWord LPAREN Expression RPAREN LBRACE SwitchCases RBRACE
					  |
					  (ForStatement) ForWord LPAREN ForExpression RPAREN MatchedStatement
					  |
					  (RecStatement) LBRACE StatementList RBRACE
					  ;

UnmatchedStatement ::= (IfElseStatement_non_else) IF LPAREN Condition RPAREN Statement
					   |
					   (IfElseStatement_else) IF LPAREN Condition RPAREN MatchedStatement ELSE UnmatchedStatement
					   ;

ReturnExpression ::= (ReturnExpression_expr) Expression
					 |
					 (ReturnExpression_non_expr) /* epsilon */ 
					 ;

PrintExpression ::= (PrintExpression_num) Expression COMMA NUMBER
					|
					(PrintExpression_non_num) Expression
					;

SwitchWord ::= (SwitchWord) SWITCH;
SwitchCases ::= (SwitchCases_s) CASE NUMBER COLON StatementList SwitchCases
				|
				(SwitchCases_e) /* epsilon */
				;

StatementList ::= (StatementList_sl) Statement StatementList
				  |
				  (StatementList_e) /* epsilon */
				  ;

ForWord ::= (ForWord) FOR;
ForExpression ::= (ConditionedForExpression) EpsilonDesignatorStatement SEMICOLON Condition SEMICOLON EpsilonDesignatorStatement
				  |
				  (NonConditionedForExpression) EpsilonDesignatorStatement SEMICOLON SEMICOLON EpsilonDesignatorStatement
				  ;


EpsilonDesignatorStatement ::= (EpsilonDesignatorStatement_ds) DesignatorStatement
							   |
							   (EpsilonDesignatorStatement_e) /* epsilon */
							   ;

DesignatorStatement ::= (ExprDesignatorStatement) Designator Assignop Expression
						|
						(ParamsDesignatorStatement) Designator LPAREN ActPars RPAREN
						|
						(IncDesignatorStatement) Designator INC
						|
						(DecDesignatorStatement) Designator DEC
						;

ActPars ::= (ActPars_params) Expression ActParsRest
			|
			(ActPars_e) /* epsilon */
			;	

ActParsRest ::= (ActParsRest_array) COMMA Expression ActParsRest
				|
				(ActParsRest_e) /* epsilon */
				;

Condition ::= (Condition) CondTerm ConditionRest;

ConditionRest ::= (ConditionRest_array) OR CondTerm ConditionRest
				  |
				  (ConditionRest_e) /* epsilon */
				  ;

CondTerm ::= (CondTerm) CondFact CondFactRest;
CondFactRest ::= (CondFactRest_array) AND CondFact CondFactRest
				 |
				 (CondFactRest_e) /* epsilon */
				 ;

CondFact ::= (NonRelopCondFact) NonTernaryExpression
			 |
			 (RelopCondFact) NonTernaryExpression Relop NonTernaryExpression
			 ;


Designator ::= (Designator_var) IDENT
			   |
			   (Designator_nest) Designator DotDesignatorOp
			   |
			   (Designator_elem) DesignatorArrayName LBRACKET Expression RBRACKET
			   ;

DesignatorArrayName ::= (DesignatorArrayName) IDENT;

DotDesignatorOp ::= (IdentDesignatorOp) DOT IDENT
					|
					(LengthDesignatorOp) DOT LENGTH
					; 


Assignop ::= (Assignop) ASSIGN;

Relop ::= (EqRelop) EQ
		  |
		  (NeqRelop) NEQ
		  |
		  (GreaterRelop) GREATER
		  |
		  (GrEqRelop) GREATER_EQUAL
		  |
		  (SmallerRelop) LESS
		  |
		  (SmEqRelop) LESS_EQUAL
		  ;

Addop ::= (PlusAddop) PLUS
		  |
		  (MinusAddop) MINUS
		  ;

Mulop ::= (MulMulop) MUL
		  |
		  (DivMulop) DIV
		  |
		  (ModMulop) MOD
		  ;

Expression ::= (NonTerExpression) NonTernaryExpression
			   |
			   (TerExpression) TernaryExpression
			   ;

NonTernaryExpression ::= (NonTernaryExpression) TermList;

TernaryExpression ::= (TernaryExpression) Condition QUESTION_MARK Expression COLON Expression;

TermList ::= (TermList_array) TermList Addop Term
			 |
			 (TermList_e) Term
			 ;

Term ::= (Term) FactorList;

FactorList ::= (FactorList_array) FactorList Mulop Factor
			   |
			   (FactorList_e) Factor
			   ;

Factor ::= (Factor) UnaryMinus PartFactor;

UnaryMinus ::= (UnaryMinus_m) MINUS
			   |
			   (UnaryMinus_e) /* epsilon*/
			   ;
		   
PartFactor ::= (DesignatorFactor_e) Designator
			   |
			   (DesignatorFactor_func) Designator LPAREN ActPars RPAREN
			   |
			   (NumberParamFactor) NUMBER
			   |
			   (CharParamFactor) CHAR
			   |
			   (BoolParamFactor) BOOL
			   |
			   (NewParamFactor) NEW Type LBRACKET Expression RBRACKET
			   |
			   (ExpParamFactor) LPAREN Expression RPAREN
			   ;