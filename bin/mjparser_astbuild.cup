package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	boolean errorDetected;
	Logger log = Logger.getLogger(getClass());

	public void report_fatal_error(String message, Object info) throws java.lang.Exception{
		done_parsing();
		report_error(message, info);
	}
	
	public void syntax_error(Symbol cur_token){
		report_error("\nSintaksna greska", cur_token);
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception{
		report_fatal_error("Fatalna greska, parsiranje nemoguce nastaviti", cur_token);
	}
	
	public void report_error(String message, Object info){
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		if(info instanceof Symbol)
			msg.append(" na liniji ").append(((Symbol)info).left);
		log.error(msg.toString());
	}
:}

init with {:
	errorDetected = false;
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if(s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM,

		 CONST,
		 ENUM,

		 NEW,
		 PRINT,
		 READ,
		 RETURN,
		 VOID,
		 BREAK,
		 CONTINUE,
		 FOR,
		 LENGTH,
		 
		 IF,
		 ELSE,
		 SWITCH,
		 CASE,
		 
		 PLUS,
		 MINUS,
		 MUL,
		 DIV,
		 MOD,
		 ASSIGN,
		 INC,
		 DEC,
		 
		 EQ,
		 NEQ,
		 GREATER,
		 GREATER_EQUAL,
		 LESS,
		 LESS_EQUAL,
		 AND,
		 OR,
		 
		 SEMICOLON,
		 COLON,
		 COMMA,
		 DOT,
		 
		 LPAREN,
		 RPAREN,
		 LBRACKET,
		 RBRACKET,
		 LBRACE,
		 RBRACE,
		 QUESTION_MARK;


terminal String IDENT;
terminal Integer BOOL, NUMBER;
terminal Character CHAR;

nonterminal Program Program;
nonterminal
			ProgramName ProgramName;
nonterminal
			
			DeclList DeclList;
nonterminal
			MethodDeclList MethodDeclList;
nonterminal
			ConstDeclList ConstDeclList;
nonterminal
			VarDeclList VarDeclList;
nonterminal
			EnumDecl EnumDecl;
nonterminal
			
			VarDiffDecl VarDiffDecl;
nonterminal
			VarDecl VarDecl;
nonterminal
			VarDeclListRest VarDeclListRest;
nonterminal
			Type Type;
nonterminal
			
			EnumItemsList EnumItemsList;
nonterminal
			EnumItemsRest EnumItemsRest;
nonterminal
			EnumItem EnumItem;
nonterminal
			EnumName EnumName;
nonterminal
			
			ConstDecl ConstDecl;
nonterminal
			ConstDeclListRest ConstDeclListRest;
nonterminal
			Constant Constant;
nonterminal
			
			Prefix Prefix;
nonterminal
			MethodDecl MethodDecl;
nonterminal
			MethodName MethodName;
nonterminal
			ParamsList ParamsList;
nonterminal
			ParamsListRest ParamsListRest;
nonterminal
			Param Param;
nonterminal
			
			Statement Statement;
nonterminal
			MatchedStatement MatchedStatement;
nonterminal
			UnmatchedStatement UnmatchedStatement;
nonterminal
			DesignatorStatement DesignatorStatement;
nonterminal
			SwitchWord SwitchWord;
nonterminal
			SwitchCases SwitchCases;
nonterminal
			ForExpression ForExpression;
nonterminal
			ForWord ForWord;
nonterminal
			StatementList StatementList;
nonterminal
			EpsilonDesignatorStatement EpsilonDesignatorStatement;
nonterminal
			
			DotDesignatorOp DotDesignatorOp;
nonterminal
			ActPars ActPars;
nonterminal
			ActParsList ActParsList;
nonterminal
			ActParsRest ActParsRest;
nonterminal

		
			UnaryMinus UnaryMinus;
nonterminal
			
			Addop Addop;
nonterminal
			Mulop Mulop;
nonterminal
			Assignop Assignop;
nonterminal
			Relop Relop;

nonterminal rs.etf.pp1.symboltable.concepts.Struct Expression, 
												   NonTernaryExpression,
												   TernaryExpression, 
												   TermList, 
												   Term, 
												   FactorList, 
												   Factor, 
												   PartFactor,
												   
												   Condition,
												   ConditionRest,
												   CondTerm,
												   CondFactRest,
												   CondFact,
												   
												   ReturnExpression,
												   PrintExpression;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator,
												DesignatorArrayName;	
			

Program ::= (Program) PROGRAM ProgramName:P1 DeclList:D2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new Program(P1, D2, M3); RESULT.setLine(P1left); :};

ProgramName ::= (ProgramName) IDENT:I1 {: RESULT=new ProgramName(I1); RESULT.setLine(I1left); :};

DeclList ::= (DeclList_const) ConstDeclList:C1 DeclList:D2 {: RESULT=new DeclList_const(C1, D2); RESULT.setLine(C1left); :}
			 |
			 (DeclList_var) VarDeclList:V1 DeclList:D2 {: RESULT=new DeclList_var(V1, D2); RESULT.setLine(V1left); :}
			 |
			 (DeclList_enum) EnumDecl:E1 DeclList:D2 {: RESULT=new DeclList_enum(E1, D2); RESULT.setLine(E1left); :}
			 |					 
			 (DeclList_e) {: RESULT=new DeclList_e(); :} /*epsilon*/
			 ;

VarDiffDecl ::= (VarDiffDecl_list) VarDeclList:V1 VarDiffDecl:V2 {: RESULT=new VarDiffDecl_list(V1, V2); RESULT.setLine(V1left); :}
				|
				(VarDiffDecl_e) {: RESULT=new VarDiffDecl_e(); :} /* epsilon */
				; 

VarDeclList ::= (VarDeclList_array) Type:T1 VarDecl:V2 VarDeclListRest:V3 SEMICOLON {: RESULT=new VarDeclList_array(T1, V2, V3); RESULT.setLine(T1left); :};

VarDeclListRest ::= (VarDeclListRest_comma) COMMA VarDecl:V1 VarDeclListRest:V2 {: RESULT=new VarDeclListRest_comma(V1, V2); RESULT.setLine(V1left); :}
					|
					(VarDeclListRest_e) {: RESULT=new VarDeclListRest_e(); :} /* epsilon */
					;

VarDecl ::= (IdentVarDecl) IDENT:I1 {: RESULT=new IdentVarDecl(I1); RESULT.setLine(I1left); :}
			|
			(ArrayVarDecl) IDENT:I1 LBRACKET RBRACKET {: RESULT=new ArrayVarDecl(I1); RESULT.setLine(I1left); :}
			;


ConstDeclList ::= (ConstDeclList) CONST Type:T1 ConstDecl:C2 ConstDeclListRest:C3 SEMICOLON {: RESULT=new ConstDeclList(T1, C2, C3); RESULT.setLine(T1left); :};

ConstDeclListRest ::= (ConstDeclListRest_comma) COMMA  ConstDecl:C1 ConstDeclListRest:C2 {: RESULT=new ConstDeclListRest_comma(C1, C2); RESULT.setLine(C1left); :}
					  |
					  (ConstDeclListRest_e) {: RESULT=new ConstDeclListRest_e(); :} /* epsilon */
					  ;

ConstDecl ::= (ConstDecl) IDENT:I1 ASSIGN Constant:C2 {: RESULT=new ConstDecl(I1, C2); RESULT.setLine(I1left); :};

Constant ::= (Constant_num) NUMBER:N1 {: RESULT=new Constant_num(N1); RESULT.setLine(N1left); :}
			 |
			 (Constant_char) CHAR:C1 {: RESULT=new Constant_char(C1); RESULT.setLine(C1left); :}
			 |
			 (Constant_bool) BOOL:B1 {: RESULT=new Constant_bool(B1); RESULT.setLine(B1left); :}
			 ;


EnumDecl ::= (EnumDecl) ENUM EnumName:E1 LBRACE EnumItemsList:E2 RBRACE {: RESULT=new EnumDecl(E1, E2); RESULT.setLine(E1left); :};

EnumItemsList ::= (EnumItemsList) EnumItem:E1 EnumItemsRest:E2 {: RESULT=new EnumItemsList(E1, E2); RESULT.setLine(E1left); :};

EnumItemsRest ::= (EnumItemsRest_comma) COMMA EnumItem:E1 EnumItemsRest:E2 {: RESULT=new EnumItemsRest_comma(E1, E2); RESULT.setLine(E1left); :}
				  |
				  (EnumItemsRest_e) {: RESULT=new EnumItemsRest_e(); :} /* epsilon */
				  ;

EnumItem ::= (IdentEnumItem) IDENT:I1 {: RESULT=new IdentEnumItem(I1); RESULT.setLine(I1left); :} 
			 |
			 (AssignEnumItem) IDENT:I1 ASSIGN NUMBER:N2 {: RESULT=new AssignEnumItem(I1, N2); RESULT.setLine(I1left); :}
			 ;
			 
EnumName ::= (EnumName) IDENT:I1 {: RESULT=new EnumName(I1); RESULT.setLine(I1left); :};


MethodDeclList ::= (MethodDeclList_array) MethodDecl:M1 MethodDeclList:M2 {: RESULT=new MethodDeclList_array(M1, M2); RESULT.setLine(M1left); :}
				   |
				   (MethodDeclList_e) {: RESULT=new MethodDeclList_e(); :} /* epsilon */
				   ;

MethodDecl ::= (MethodDecl) Prefix:P1 MethodName:M2 LPAREN ParamsList:P3 RPAREN VarDiffDecl:V4 LBRACE StatementList:S5 RBRACE {: RESULT=new MethodDecl(P1, M2, P3, V4, S5); RESULT.setLine(P1left); :};

Prefix ::= (TypePrefix) Type:T1 {: RESULT=new TypePrefix(T1); RESULT.setLine(T1left); :}
		   |
		   (VoidPrefix) VOID {: RESULT=new VoidPrefix(); :}
		   ;

MethodName ::= (MethodName) IDENT:I1 {: RESULT=new MethodName(I1); RESULT.setLine(I1left); :};

ParamsList ::= (ParamsList_param) Type:T1 VarDecl:V2 ParamsListRest:P3 {: RESULT=new ParamsList_param(T1, V2, P3); RESULT.setLine(T1left); :}
			   |
			   (ParamsList_e) {: RESULT=new ParamsList_e(); :}/* epsilon */ 
			   ;

ParamsListRest ::= (ParamsListRest_param) COMMA Type:T1 VarDecl:V2 ParamsListRest:P3 {: RESULT=new ParamsListRest_param(T1, V2, P3); RESULT.setLine(T1left); :}
				   |
				   (ParamsListRest_e) {: RESULT=new ParamsListRest_e(); :} /* epsilon */
				   ;

Type ::= (Type) IDENT:I1 {: RESULT=new Type(I1); RESULT.setLine(I1left); :};

Statement ::= (MatchStatement) MatchedStatement:M1 {: RESULT=new MatchStatement(M1); RESULT.setLine(M1left); :}
			  |
			  (UnmatchStatement) UnmatchedStatement:U1 {: RESULT=new UnmatchStatement(U1); RESULT.setLine(U1left); :}
			  ;

MatchedStatement ::=  (DesigStatement) DesignatorStatement:D1 SEMICOLON {: RESULT=new DesigStatement(D1); RESULT.setLine(D1left); :}
					  |
					  (IfElseStatement) IF LPAREN Condition:C1 RPAREN MatchedStatement:M2 ELSE MatchedStatement:M3 {: RESULT=new IfElseStatement(C1, M2, M3); RESULT.setLine(C1left); :}
					  |
					  (BreakStatement) BREAK SEMICOLON {: RESULT=new BreakStatement(); :}
					  |
					  (ContinueStatement) CONTINUE SEMICOLON {: RESULT=new ContinueStatement(); :}
					  |
					  (ReturnStatement) RETURN ReturnExpression:R1 SEMICOLON {: RESULT=new ReturnStatement(R1); RESULT.setLine(R1left); :}
					  |
					  (ReadStatement) READ LPAREN Designator:D1 RPAREN SEMICOLON {: RESULT=new ReadStatement(D1); RESULT.setLine(D1left); :}
					  |
					  (PrintStatement) PRINT LPAREN PrintExpression:P1 RPAREN SEMICOLON {: RESULT=new PrintStatement(P1); RESULT.setLine(P1left); :}
					  |
					  (SwitchStatement) SwitchWord:S1 LPAREN Expression:E2 RPAREN LBRACE SwitchCases:S3 RBRACE {: RESULT=new SwitchStatement(S1, E2, S3); RESULT.setLine(S1left); :}
					  |
					  (ForStatement) ForWord:F1 LPAREN ForExpression:F2 RPAREN MatchedStatement:M3 {: RESULT=new ForStatement(F1, F2, M3); RESULT.setLine(F1left); :}
					  |
					  (RecStatement) LBRACE StatementList:S1 RBRACE {: RESULT=new RecStatement(S1); RESULT.setLine(S1left); :}
					  ;

UnmatchedStatement ::= (IfElseStatement_non_else) IF LPAREN Condition:C1 RPAREN Statement:S2 {: RESULT=new IfElseStatement_non_else(C1, S2); RESULT.setLine(C1left); :}
					   |
					   (IfElseStatement_else) IF LPAREN Condition:C1 RPAREN MatchedStatement:M2 ELSE UnmatchedStatement:U3 {: RESULT=new IfElseStatement_else(C1, M2, U3); RESULT.setLine(C1left); :}
					   ;

ReturnExpression ::= (ReturnExpression_expr) Expression:E1 {: RESULT=new ReturnExpression_expr(E1); RESULT.setLine(E1left); :}
					 |
					 (ReturnExpression_non_expr) {: RESULT=new ReturnExpression_non_expr(); :} /* epsilon */ 
					 ;

PrintExpression ::= (PrintExpression_num) Expression:E1 COMMA NUMBER:N2 {: RESULT=new PrintExpression_num(E1, N2); RESULT.setLine(E1left); :}
					|
					(PrintExpression_non_num) Expression:E1 {: RESULT=new PrintExpression_non_num(E1); RESULT.setLine(E1left); :}
					;

SwitchWord ::= (SwitchWord) SWITCH {: RESULT=new SwitchWord(); :};
SwitchCases ::= (SwitchCases_s) CASE NUMBER:N1 COLON StatementList:S2 SwitchCases:S3 {: RESULT=new SwitchCases_s(N1, S2, S3); RESULT.setLine(N1left); :}
				|
				(SwitchCases_e) {: RESULT=new SwitchCases_e(); :} /* epsilon */
				;

StatementList ::= (StatementList_sl) Statement:S1 StatementList:S2 {: RESULT=new StatementList_sl(S1, S2); RESULT.setLine(S1left); :}
				  |
				  (StatementList_e) {: RESULT=new StatementList_e(); :} /* epsilon */
				  ;

ForWord ::= (ForWord) FOR {: RESULT=new ForWord(); :};
ForExpression ::= (ConditionedForExpression) EpsilonDesignatorStatement:E1 SEMICOLON Condition:C2 SEMICOLON EpsilonDesignatorStatement:E3 {: RESULT=new ConditionedForExpression(E1, C2, E3); RESULT.setLine(E1left); :}
				  |
				  (NonConditionedForExpression) EpsilonDesignatorStatement:E1 SEMICOLON SEMICOLON EpsilonDesignatorStatement:E2 {: RESULT=new NonConditionedForExpression(E1, E2); RESULT.setLine(E1left); :}
				  ;


EpsilonDesignatorStatement ::= (EpsilonDesignatorStatement_ds) DesignatorStatement:D1 {: RESULT=new EpsilonDesignatorStatement_ds(D1); RESULT.setLine(D1left); :}
							   |
							   (EpsilonDesignatorStatement_e) {: RESULT=new EpsilonDesignatorStatement_e(); :} /* epsilon */
							   ;

DesignatorStatement ::= (ExprDesignatorStatement) Designator:D1 Assignop:A2 Expression:E3 {: RESULT=new ExprDesignatorStatement(D1, A2, E3); RESULT.setLine(D1left); :}
						|
						(ParamsDesignatorStatement) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new ParamsDesignatorStatement(D1, A2); RESULT.setLine(D1left); :}
						|
						(IncDesignatorStatement) Designator:D1 INC {: RESULT=new IncDesignatorStatement(D1); RESULT.setLine(D1left); :}
						|
						(DecDesignatorStatement) Designator:D1 DEC {: RESULT=new DecDesignatorStatement(D1); RESULT.setLine(D1left); :}
						;

ActPars ::= (ActPars_params) Expression:E1 ActParsRest:A2 {: RESULT=new ActPars_params(E1, A2); RESULT.setLine(E1left); :}
			|
			(ActPars_e) {: RESULT=new ActPars_e(); :} /* epsilon */
			;	

ActParsRest ::= (ActParsRest_array) COMMA Expression:E1 ActParsRest:A2 {: RESULT=new ActParsRest_array(E1, A2); RESULT.setLine(E1left); :}
				|
				(ActParsRest_e) {: RESULT=new ActParsRest_e(); :} /* epsilon */
				;

Condition ::= (Condition) CondTerm:C1 ConditionRest:C2 {: RESULT=new Condition(C1, C2); RESULT.setLine(C1left); :};

ConditionRest ::= (ConditionRest_array) OR CondTerm:C1 ConditionRest:C2 {: RESULT=new ConditionRest_array(C1, C2); RESULT.setLine(C1left); :}
				  |
				  (ConditionRest_e) {: RESULT=new ConditionRest_e(); :} /* epsilon */
				  ;

CondTerm ::= (CondTerm) CondFact:C1 CondFactRest:C2 {: RESULT=new CondTerm(C1, C2); RESULT.setLine(C1left); :};
CondFactRest ::= (CondFactRest_array) AND CondFact:C1 CondFactRest:C2 {: RESULT=new CondFactRest_array(C1, C2); RESULT.setLine(C1left); :}
				 |
				 (CondFactRest_e) {: RESULT=new CondFactRest_e(); :} /* epsilon */
				 ;

CondFact ::= (NonRelopCondFact) NonTernaryExpression:N1 {: RESULT=new NonRelopCondFact(N1); RESULT.setLine(N1left); :}
			 |
			 (RelopCondFact) NonTernaryExpression:N1 Relop:R2 NonTernaryExpression:N3 {: RESULT=new RelopCondFact(N1, R2, N3); RESULT.setLine(N1left); :}
			 ;


Designator ::= (Designator_var) IDENT:I1 {: RESULT=new Designator_var(I1); RESULT.setLine(I1left); :}
			   |
			   (Designator_nest) Designator:D1 DotDesignatorOp:D2 {: RESULT=new Designator_nest(D1, D2); RESULT.setLine(D1left); :}
			   |
			   (Designator_elem) DesignatorArrayName:D1 LBRACKET Expression:E2 RBRACKET {: RESULT=new Designator_elem(D1, E2); RESULT.setLine(D1left); :}
			   ;

DesignatorArrayName ::= (DesignatorArrayName) IDENT:I1 {: RESULT=new DesignatorArrayName(I1); RESULT.setLine(I1left); :};

DotDesignatorOp ::= (IdentDesignatorOp) DOT IDENT:I1 {: RESULT=new IdentDesignatorOp(I1); RESULT.setLine(I1left); :}
					|
					(LengthDesignatorOp) DOT LENGTH {: RESULT=new LengthDesignatorOp(); :}
					; 


Assignop ::= (Assignop) ASSIGN {: RESULT=new Assignop(); :};

Relop ::= (EqRelop) EQ {: RESULT=new EqRelop(); :}
		  |
		  (NeqRelop) NEQ {: RESULT=new NeqRelop(); :}
		  |
		  (GreaterRelop) GREATER {: RESULT=new GreaterRelop(); :}
		  |
		  (GrEqRelop) GREATER_EQUAL {: RESULT=new GrEqRelop(); :}
		  |
		  (SmallerRelop) LESS {: RESULT=new SmallerRelop(); :}
		  |
		  (SmEqRelop) LESS_EQUAL {: RESULT=new SmEqRelop(); :}
		  ;

Addop ::= (PlusAddop) PLUS {: RESULT=new PlusAddop(); :}
		  |
		  (MinusAddop) MINUS {: RESULT=new MinusAddop(); :}
		  ;

Mulop ::= (MulMulop) MUL {: RESULT=new MulMulop(); :}
		  |
		  (DivMulop) DIV {: RESULT=new DivMulop(); :}
		  |
		  (ModMulop) MOD {: RESULT=new ModMulop(); :}
		  ;

Expression ::= (NonTerExpression) NonTernaryExpression:N1 {: RESULT=new NonTerExpression(N1); RESULT.setLine(N1left); :}
			   |
			   (TerExpression) TernaryExpression:T1 {: RESULT=new TerExpression(T1); RESULT.setLine(T1left); :}
			   ;

NonTernaryExpression ::= (NonTernaryExpression) TermList:T1 {: RESULT=new NonTernaryExpression(T1); RESULT.setLine(T1left); :};

TernaryExpression ::= (TernaryExpression) Condition:C1 QUESTION_MARK Expression:E2 COLON Expression:E3 {: RESULT=new TernaryExpression(C1, E2, E3); RESULT.setLine(C1left); :};

TermList ::= (TermList_array) TermList:T1 Addop:A2 Term:T3 {: RESULT=new TermList_array(T1, A2, T3); RESULT.setLine(T1left); :}
			 |
			 (TermList_e) Term:T1 {: RESULT=new TermList_e(T1); RESULT.setLine(T1left); :}
			 ;

Term ::= (Term) FactorList:F1 {: RESULT=new Term(F1); RESULT.setLine(F1left); :};

FactorList ::= (FactorList_array) FactorList:F1 Mulop:M2 Factor:F3 {: RESULT=new FactorList_array(F1, M2, F3); RESULT.setLine(F1left); :}
			   |
			   (FactorList_e) Factor:F1 {: RESULT=new FactorList_e(F1); RESULT.setLine(F1left); :}
			   ;

Factor ::= (Factor) UnaryMinus:U1 PartFactor:P2 {: RESULT=new Factor(U1, P2); RESULT.setLine(U1left); :};

UnaryMinus ::= (UnaryMinus_m) MINUS {: RESULT=new UnaryMinus_m(); :}
			   |
			   (UnaryMinus_e) {: RESULT=new UnaryMinus_e(); :} /* epsilon*/
			   ;
		   
PartFactor ::= (DesignatorFactor_e) Designator:D1 {: RESULT=new DesignatorFactor_e(D1); RESULT.setLine(D1left); :}
			   |
			   (DesignatorFactor_func) Designator:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new DesignatorFactor_func(D1, A2); RESULT.setLine(D1left); :}
			   |
			   (NumberParamFactor) NUMBER:N1 {: RESULT=new NumberParamFactor(N1); RESULT.setLine(N1left); :}
			   |
			   (CharParamFactor) CHAR:C1 {: RESULT=new CharParamFactor(C1); RESULT.setLine(C1left); :}
			   |
			   (BoolParamFactor) BOOL:B1 {: RESULT=new BoolParamFactor(B1); RESULT.setLine(B1left); :}
			   |
			   (NewParamFactor) NEW Type:T1 LBRACKET Expression:E2 RBRACKET {: RESULT=new NewParamFactor(T1, E2); RESULT.setLine(T1left); :}
			   |
			   (ExpParamFactor) LPAREN Expression:E1 RPAREN {: RESULT=new ExpParamFactor(E1); RESULT.setLine(E1left); :}
			   ;